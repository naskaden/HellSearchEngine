<h1 align="center">HellSearchEngine</h1>
<h1 align="center">Система поиска документов по базе данных</h1>

_______

## Описание
Проект позволяет анализировать текст документов базы данных и определять наиболее релевантные 
документы в соответствии с поисковым запросом.

## Структура проекта

Проект включает в себя следующие классы:
1. Base - хранилище текстов базы данных, частотного словаря и путей к используемым файлам.
2. Creator - предназначен для формирования файлов `config.json` и `requests.json`.
3. ConverterJSON - считывает тексты документов базы данных и необходимую информацию из файлов `config.json` и `requests.json`, записывает ответы в файл `answers.json`.
4. InvertedIndex - формирует частотный словарь, по которому осуществляется поиск запросов.
5. SearchServer - осуществляет поиск запросов по базе данных.
6. ThreadPool - реализует пул потоков для многопоточного формирования частотного словаря.

## Начало работы

Для работы с проектом необходимо наличие двух файлов: `config.json` и `requests.json`. Файлы находятся в 
директории `bin`. В этой же директории желательно осуществлять сборку проекта. 

Содержимое файла `config.json`:
```json
{
    "config": {
      "max_responses": 5,
      "name": "HellSearchEngine",
      "version": 0.1
    },
    "files": [
      "../resources\\file0.txt",
      "../resources\\file1.txt",
      "../resources\\file2.txt",
      "../resources\\file3.txt",
      "../resources\\file4.txt"
    ]
}
```
Поле `config` содержит информацию о названии проекта `name`, версии `version` и 
максимальном количестве ответов `max_responses` на один запрос. Поле `files` содержит пути
к файлам базы данных, по которой будет осуществлятся поиск.

Содержимое файла `requests.json`:
```json
{
    "requests": [
        "lemon, sugar, vanilla",
        "unsalted butter",
        "carrot"
    ]
}
```
Поле `requests` содержит список поисковых запросов. В данном примере 3 запроса: `lemon, sugar, vanilla`,
`unsalted butter` и `carrot`.

Если файлы `config.json` и `requests.json` отсутствуют, программа предложит создать их.


## Запуск поиска

Первый вариант (по умолчанию) - поиск исходя из информации в файлах `config.json` и `requests.json`. Для этого 
необходимо раскомментировать макрос `SEARCH` в `main.cpp` и запустить проект.

Второй вариант - ввод текстов и запросов в коде. Для этого необходимо раскомментировать макрос
`DIRECT_INPUT` в `main.cpp` и заполнить переменные `docs` и `requests`. В этом случае необходим только файл `config.json` 
с заполненным полем `config` (остальные поля, а также файл `requests.json` не считываются).

Также возможна комбинация, например ввод запроса в коде и поиск по файлам из `config.json`, и наоборот.

### Последовательность вызова функций 
1. Создание объекта типа `Base`, в котором будут храниться тексты документов `docs` и частотный словарь `freq_dictionary`.
2. Вызов `InvertedIndex::UpdateDocumentBase` с передачей указателя на `Base`. В результате работы функции формируются `docs` и `freq_dictionary`.
3. Вызов `SearchServer::Search` с передачей указателя на `Base`. В результате работы функции формируются ответы на запросы.
4. Запись ответов в файл `answers.json` с помощью вызова `ConverterJSON::PutAnswers` с передачей указателей на `Base` и результат поиска.


При вводе текста и/или запросов вручную в коде необходимо дополнительно передавать указатели на `docs` и `requests` в функции `InvertedIndex::UpdateDocumentBase` и `SearchServer::Search` соответственно.

__Note__: cлова в текстах могут разделятся следующими символами: ` ,;:."!?'*`

## Результат поиска

Ответы на запросы записываются в файл `answers.json`. Максимальное отображаемое количество документов на один запрос 
указано в `max_responses` в `config.json`.

<details>

<summary> answers.json </summary>

```json
{
  "answers": {
    "request001": {
      "result": "true",
      "relevance": [
        {
          "docid": 2,
          "rank": 1.0
        },
        {
          "docid": 3,
          "rank": 1.0
        },
        {
          "docid": 0,
          "rank": 0.6700000166893005
        },
        {
          "docid": 1,
          "rank": 0.6700000166893005
        },
        {
          "docid": 4,
          "rank": 0.6700000166893005
        }
      ]
    },
    "request002": {
      "result": "true",
      "relevance": [
        {
          "docid": 4,
          "rank": 1.0
        },
        {
          "docid": 1,
          "rank": 0.6700000166893005
        },
        {
          "docid": 2,
          "rank": 0.6700000166893005
        },
        {
          "docid": 3,
          "rank": 0.6700000166893005
        }
      ]
    },
    "request003": {
      "result": "false",
      "relevance": [
        {
          "docid": 4,
          "rank": 1.0
        },
        {
          "docid": 1,
          "rank": 0.6700000166893005
        },
        {
          "docid": 2,
          "rank": 0.6700000166893005
        },
        {
          "docid": 3,
          "rank": 0.6700000166893005
        }
      ]
    }
  }
}
```
</details>

Поле `request` содержит ответ на запрос с соответствующим номером. Например, `request001` - 
это ответ на запрос `lemon, sugar, vanilla`, указанный в файле `requests.json`. Ответ состоит из флага результата 
поиска `result` и поля `relevance`, которое содержит номера документов `docid`, в которых найдены 
слова из запроса, и относительная релевантность этих документов `rank`. Документы перечислены в порядке убывания релевантности.

Относительная релевантность получена делением абсолютной релевантности для конкретного документа на максимальную абсолютную релевантность
среди всех документов. Абсолютная релевантность документа представляет собой сумму частот слов из запроса.  

## Многопоточность
Многопоточность используется при формировании частотного словаря для обработки каждого документа в отдельном потоке.
Реализованы два варианта: создание объекта пула потоков ThreadPool с очередью задач (стоит по умолчанию) и просто создание вектора потоков.

Для работы с первым вариантом необходимо раскомментировать макросы `MULTITHREAD` и `THREADPOOL` в файле `InvertedIndex.h`:
```
//#define SINGLETHREAD
#define MULTITHREAD

#ifdef MULTITHREAD
//#define VECTORTHREAD
#define THREADPOOL
```
Для работы со вторым вариантом необходимо раскомментировать `MULTITHREAD` и `VECTORTHREAD` в файле `InvertedIndex.h`:
```
//#define SINGLETHREAD
#define MULTITHREAD

#ifdef MULTITHREAD
#define VECTORTHREAD
//#define THREADPOOL
```

Для работы в однопоточном режиме необходимо раскомментировать `SINGLETHREAD` и закомментировать `MULTITHREAD` в файле `InvertedIndex.h`:
```
#define SINGLETHREAD
//#define MULTITHREAD
```
## Тестирование
Unit-nестирование работы классов `InvertedIndex` и `SearchServer` реализовано с использованием Google Test. Тесты находятся в директории `tests`.
Для тестирования обязательно наличие заполненного файла `config.json` в директории `bin`.






